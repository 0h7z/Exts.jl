var documenterSearchIndex = {"docs":
[{"location":"Pkg/#API-reference","page":"Pkg","title":"API reference","text":"","category":"section"},{"location":"Pkg/#PkgExt.PkgExt","page":"Pkg","title":"PkgExt.PkgExt","text":"PkgExt\n\n\n\n\n\n","category":"module"},{"location":"Pkg/#Types","page":"Pkg","title":"Types","text":"","category":"section"},{"location":"Pkg/#Macros","page":"Pkg","title":"Macros","text":"","category":"section"},{"location":"Pkg/#Functions","page":"Pkg","title":"Functions","text":"","category":"section"},{"location":"Pkg/#Exts.with_temp_env-Tuple{Function}","page":"Pkg","title":"Exts.with_temp_env","text":"Exts.with_temp_env(f::Function)\n\nEquivalent to Pkg.Operations.with_temp_env(f, \"@stdlib\").\n\n\n\n\n\n","category":"method"},{"location":"Statistics/#API-reference","page":"Statistics","title":"API reference","text":"","category":"section"},{"location":"Statistics/#StatisticsExt.StatisticsExt","page":"Statistics","title":"StatisticsExt.StatisticsExt","text":"StatisticsExt\n\n\n\n\n\n","category":"module"},{"location":"Statistics/#Types","page":"Statistics","title":"Types","text":"","category":"section"},{"location":"Statistics/#Macros","page":"Statistics","title":"Macros","text":"","category":"section"},{"location":"Statistics/#Functions","page":"Statistics","title":"Functions","text":"","category":"section"},{"location":"Statistics/#Exts.nanmean-Tuple{AbstractArray, StatsBase.AbstractWeights}","page":"Statistics","title":"Exts.nanmean","text":"nanmean(A::AbstractArray, w::AbstractWeights; dims = :)\n\nCompute the weighted mean of array A with weight vector w, and fallback to the unweighted mean if w is all zero(s) (instead of returning NaN). If dims (of type Int) is provided, compute the mean along dimension dims.\n\nSee also mean(::AbstractArray), mean(::AbstractArray, ::AbstractWeights).\n\n\n\n\n\n","category":"method"},{"location":"DataFrames/#API-reference","page":"DataFrames","title":"API reference","text":"","category":"section"},{"location":"DataFrames/#DataFramesExt.DataFramesExt","page":"DataFrames","title":"DataFramesExt.DataFramesExt","text":"DataFramesExt\n\n\n\n\n\n","category":"module"},{"location":"DataFrames/#Types","page":"DataFrames","title":"Types","text":"","category":"section"},{"location":"DataFrames/#Macros","page":"DataFrames","title":"Macros","text":"","category":"section"},{"location":"DataFrames/#Functions","page":"DataFrames","title":"Functions","text":"","category":"section"},{"location":"DataFrames/#Base.read","page":"DataFrames","title":"Base.read","text":"read(s::IOStream, DataFrame, colnames = nothing;\n\tquotes = true, comments = true, comment_char = '#') -> DataFrame\n\nRead a DataFrame from the given I/O stream or file where each line gives one row.\n\nIf colnames is not provided (or, is nothing), the first row of data will be read as header. If colnames is the symbol :auto, the column names will be x1, x2, and so on. Otherwise, colnames must be a vector of symbols or strings to specify column names.\n\nIf quotes is true, columns enclosed within double-quote (\") characters are allowed to contain new lines and column delimiters. Double-quote characters within a quoted field must be escaped with another double-quote.\n\nIf comments is true, lines beginning with comment_char and text following comment_char in any line are ignored.\n\n\n\n\n\n","category":"function"},{"location":"DataFrames/#Base.read-Tuple{AbstractString, Type{DataFrames.DataFrame}, Vararg{Any}}","page":"DataFrames","title":"Base.read","text":"read(f::AbstractString, DataFrame, colnames = nothing;\n\tquotes = true, comments = true, comment_char = '#') -> DataFrame\n\nRead a DataFrame from the given I/O stream or file where each line gives one row.\n\nIf colnames is not provided (or, is nothing), the first row of data will be read as header. If colnames is the symbol :auto, the column names will be x1, x2, and so on. Otherwise, colnames must be a vector of symbols or strings to specify column names.\n\nIf quotes is true, columns enclosed within double-quote (\") characters are allowed to contain new lines and column delimiters. Double-quote characters within a quoted field must be escaped with another double-quote.\n\nIf comments is true, lines beginning with comment_char and text following comment_char in any line are ignored.\n\n\n\n\n\n","category":"method"},{"location":"DataFrames/#Base.write-Tuple{AbstractString, DataFrames.AbstractDataFrame}","page":"DataFrames","title":"Base.write","text":"write(f::AbstractString, x::AbstractDataFrame; delim = '\\t', header = true) -> Int64\n\nWrite a DataFrame as text to the given I/O stream or file, using the given delimiter delim (which defaults to tab, but can be anything printable, typically a character or string).\n\nReturn the number of bytes written into the stream or file.\n\n\n\n\n\n","category":"method"},{"location":"DataFrames/#Base.write-Tuple{IOStream, DataFrames.AbstractDataFrame}","page":"DataFrames","title":"Base.write","text":"write(s::IOStream, x::AbstractDataFrame; delim = '\\t', header = true) -> Int64\n\nWrite a DataFrame as text to the given I/O stream or file, using the given delimiter delim (which defaults to tab, but can be anything printable, typically a character or string).\n\nReturn the number of bytes written into the stream or file.\n\n\n\n\n\n","category":"method"},{"location":"YAML/#API-reference","page":"YAML","title":"API reference","text":"","category":"section"},{"location":"YAML/#YAMLExt.YAMLExt","page":"YAML","title":"YAMLExt.YAMLExt","text":"YAMLExt\n\n\n\n\n\n","category":"module"},{"location":"YAML/#Types","page":"YAML","title":"Types","text":"","category":"section"},{"location":"YAML/#Macros","page":"YAML","title":"Macros","text":"","category":"section"},{"location":"YAML/#Functions","page":"YAML","title":"Functions","text":"","category":"section"},{"location":"YAML/#YAML.yaml-Tuple","page":"YAML","title":"YAML.yaml","text":"yaml(data...; delim = \"\") -> String\n\nReturn a YAML-formatted string of the data.\n\n\n\n\n\n","category":"method"},{"location":"Base/#API-reference","page":"Base","title":"API reference","text":"","category":"section"},{"location":"Base/#Exts.BaseExt","page":"Base","title":"Exts.BaseExt","text":"BaseExt\n\n\n\n\n\n","category":"module"},{"location":"Base/#Types","page":"Base","title":"Types","text":"","category":"section"},{"location":"Base/#Base.Bottom","page":"Base","title":"Base.Bottom","text":"Bottom <- Union{}\n\nSee Union{}.\n\n\n\n\n\n","category":"type"},{"location":"Base/#Base.Fix1","page":"Base","title":"Base.Fix1","text":"Fix1(f, x) -> Function\n\nSee Base.Fix1.\n\n\n\n\n\n","category":"type"},{"location":"Base/#Base.Fix2","page":"Base","title":"Base.Fix2","text":"Fix2(f, x) -> Function\n\nSee Base.Fix2.\n\n\n\n\n\n","category":"type"},{"location":"Base/#Macros","page":"Base","title":"Macros","text":"","category":"section"},{"location":"Base/#Functions","page":"Base","title":"Functions","text":"","category":"section"},{"location":"Base/#Base.log10-Union{Tuple{T}, Tuple{T, T}} where T<:Real","page":"Base","title":"Base.log10","text":"log10(x::T, σ::T) where T <: Real -> NTuple{2, AbstractFloat}\n\nCompute the logarithm of x ± σ to base 10.\n\nSee also log10(x).\n\n\n\n\n\n","category":"method"},{"location":"#Exts.jl","page":"Manual","title":"Exts.jl","text":"","category":"section"},{"location":"","page":"Manual","title":"Manual","text":"(Image: CI status) (Image: codecov.io)","category":"page"},{"location":"","page":"Manual","title":"Manual","text":"","category":"page"},{"location":"#Usage","page":"Manual","title":"Usage","text":"","category":"section"},{"location":"","page":"Manual","title":"Manual","text":"pkg> registry add https://github.com/0h7z/0hjl.git\npkg> add Exts","category":"page"},{"location":"","page":"Manual","title":"Manual","text":"julia> using Exts\n\njulia> Exts.ext(:) # to see which extensions are loaded\n8-element Vector{Pair{Symbol, Union{Nothing, Module}}}:\n             :Base => Exts.BaseExt\n       :DataFrames => DataFramesExt\n            :Dates => DatesExt\n           :FITSIO => FITSIOExt\n :FITSIODataFrames => FITSIODataFramesExt\n              :Pkg => PkgExt\n       :Statistics => StatisticsExt\n             :YAML => YAMLExt","category":"page"},{"location":"","page":"Manual","title":"Manual","text":"","category":"page"},{"location":"#API-reference","page":"Manual","title":"API reference","text":"","category":"section"},{"location":"#Types","page":"Manual","title":"Types","text":"","category":"section"},{"location":"#Exts.Datum","page":"Manual","title":"Exts.Datum","text":"Datum{T} <- Union{T, Missing}\ndatum(T::Type...) -> Datum{Union{T...}}\n\n\n\n\n\n","category":"type"},{"location":"#Exts.IntOrStr","page":"Manual","title":"Exts.IntOrStr","text":"IntOrStr <- Union{AbstractString, Integer}\n\n\n\n\n\n","category":"type"},{"location":"#Exts.Maybe","page":"Manual","title":"Exts.Maybe","text":"Maybe{T} <- Union{T, Nothing}\nmaybe(T::Type...) -> Maybe{Union{T...}}\n\n\n\n\n\n","category":"type"},{"location":"#Exts.SymOrStr","page":"Manual","title":"Exts.SymOrStr","text":"SymOrStr <- Union{AbstractString, Symbol}\n\n\n\n\n\n","category":"type"},{"location":"#Exts.VType","page":"Manual","title":"Exts.VType","text":"VType    <- Union{Type, TypeofVararg}\n\n\n\n\n\n","category":"type"},{"location":"#Exts.VecOrTup","page":"Manual","title":"Exts.VecOrTup","text":"VecOrTup <- Union{AbstractVector, Tuple}\n\n\n\n\n\n","category":"type"},{"location":"#Exts.LDict","page":"Manual","title":"Exts.LDict","text":"LDict <- LittleDict\n\nAn ordered dictionary type for small numbers of keys. Rather than using hash or some other sophisticated measure to store the vals in a clever arrangement, it just keeps everything in a pair of lists.\n\nWhile theoretically this has expected time complexity O(n) (vs the hash-based OrderedDict/Dict's expected time complexity O(1), and the search-tree-based SortedDict's expected time complexity O(log n)), in practice it is really fast, because it is cache & SIMD friendly.\n\nIt is reasonable to expect it to outperform an OrderedDict, with up to around 30 elements in general; or with up to around 50 elements if using a LittleDict backed by Tuples (see freeze). However, this depends on exactly how long isequal and hash take, as well as on how many hash collisions occur etc.\n\nnote: Note\nWhen constructing a LittleDict it is faster to pass in the keys and values each as separate lists. So if you have them seperately already, do LittleDict(ks, vs) not LittleDict(zip(ks, vs)). Furthermore, key and value lists that are passed as Tuples will not require any copies to create the LittleDict, so LittleDict(ks::Tuple, vs::Tuple) is the fastest constructor of all.\n\nwarning: Warning\nWhen constructing a LittleDict, unlike hash-based OrderedDict/Dict, it does not guarantee that the keys are unique but assumes so. Use at your own risk if there might be duplicate keys.\n\nSee also LittleDicts.\n\n\n\n\n\n","category":"type"},{"location":"#Exts.ODict","page":"Manual","title":"Exts.ODict","text":"ODict <- OrderedDict\n\nOrderedDicts are simply dictionaries whose entries have a particular order. The order refers to insertion order, which allows deterministic iteration over the dictionary.\n\nSee also OrderedDicts.\n\n\n\n\n\n","category":"type"},{"location":"#Exts.OSet","page":"Manual","title":"Exts.OSet","text":"OSet  <- OrderedSet\n\nOrderedSets are simply sets whose entries have a particular order. The order refers to insertion order, which allows deterministic iteration over the set.\n\nSee also OrderedSets.\n\n\n\n\n\n","category":"type"},{"location":"#Exts.UDict","page":"Manual","title":"Exts.UDict","text":"UDict <- Dict # UnorderedDict\n\nSee Base.Dict.\n\n\n\n\n\n","category":"type"},{"location":"#Exts.USet","page":"Manual","title":"Exts.USet","text":"USet  <- Set  # UnorderedSet\n\nSee Base.Set.\n\n\n\n\n\n","category":"type"},{"location":"#Exts.VTuple","page":"Manual","title":"Exts.VTuple","text":"VTuple{T}  <- VTuple0{T}\nVTuple0{T} <- Tuple{Vararg{T}}          # 0 or more\nVTuple1{T} <- Tuple{T, Vararg{T}}       # 1 or more\nVTuple2{T} <- Tuple{T, T, Vararg{T}}    # 2 or more\nVTuple3{T} <- Tuple{T, T, T, Vararg{T}} # 3 or more\n\n\n\n\n\n","category":"type"},{"location":"#Macros","page":"Manual","title":"Macros","text":"","category":"section"},{"location":"#Exts.@S_str-Tuple{Any}","page":"Manual","title":"Exts.@S_str","text":"@S_str -> Symbol\n\nCreate a Symbol from a literal string.\n\nExamples\n\njulia> S\"Julia\"\n:Julia\n\njulia> S\"$0 expands to the name of the shell or shell script.\"\nSymbol(\"\\$0 expands to the name of the shell or shell script.\")\n\n\n\n\n\n","category":"macro"},{"location":"#Exts.@catch","page":"Manual","title":"Exts.@catch","text":"@catch expr default = nothing\n\nEvaluate the expression with a try/catch construct and return the thrown exception. If no error (exception) occurs, return default.\n\nSee also The try/catch statement, try/catch, @trycatch, @try.\n\n\n\n\n\n","category":"macro"},{"location":"#Exts.@disp-Tuple{Expr}","page":"Manual","title":"Exts.@disp","text":"@disp expr[...] -> Nothing\n\nEvaluate an expression and display the result.\n\nSee also @show, display.\n\nExamples\n\njulia> @disp Maybe{AbstractVecOrMat}\nUnion{Nothing, AbstractVecOrMat}\n\njulia> @disp Maybe{AbstractVecOrMat}...\nNothing\nAbstractVector (alias for AbstractArray{T, 1} where T)\nAbstractMatrix (alias for AbstractArray{T, 2} where T)\n\njulia> @disp \"+-×÷\"...\n'+': ASCII/Unicode U+002B (category Sm: Symbol, math)\n'-': ASCII/Unicode U+002D (category Pd: Punctuation, dash)\n'×': Unicode U+00D7 (category Sm: Symbol, math)\n'÷': Unicode U+00F7 (category Sm: Symbol, math)\n\n\n\n\n\n","category":"macro"},{"location":"#Exts.@noinfo-Tuple{Any}","page":"Manual","title":"Exts.@noinfo","text":"@noinfo expr\n\nSuppress all lexically-enclosed uses of @debug, @info.\n\n\n\n\n\n","category":"macro"},{"location":"#Exts.@nowarn-Tuple{Any}","page":"Manual","title":"Exts.@nowarn","text":"@nowarn expr\n\nSuppress all lexically-enclosed uses of @debug, @info, @warn.\n\n\n\n\n\n","category":"macro"},{"location":"#Exts.@try","page":"Manual","title":"Exts.@try","text":"@try expr default = nothing\n\nEvaluate the expression with a try/catch construct and return the result. If any error (exception) occurs, return default.\n\nSee also The try/catch statement, try/catch, @trycatch, @catch.\n\n\n\n\n\n","category":"macro"},{"location":"#Exts.@trycatch","page":"Manual","title":"Exts.@trycatch","text":"@trycatch expr func = identity\n\nEvaluate the expression with a try/catch construct and return either the result or the thrown exception (passed to and processed by func), whichever available.\n\nSee also The try/catch statement, try/catch, @try, @catch.\n\n\n\n\n\n","category":"macro"},{"location":"#Functions","page":"Manual","title":"Functions","text":"","category":"section"},{"location":"#Exts.cis-Tuple{Real}","page":"Manual","title":"Exts.cis","text":"Exts.cis(x::Real) -> Complex{<:AbstractFloat}\n\nMore accurate method for exp(im*x) (especially for large x).\n\nSee also ∠, polar, Base.cis, cispi.\n\nExamples\n\njulia> -1 == -Exts.cis(2π) == Exts.cis(-π) == Exts.cis(π)\ntrue\n\njulia> -1 != -Base.cis(2π) != Base.cis(-π) != Base.cis(π)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"#Exts.datum","page":"Manual","title":"Exts.datum","text":"Datum{T} <- Union{T, Missing}\ndatum(T::Type...) -> Datum{Union{T...}}\n\n\n\n\n\n","category":"function"},{"location":"#Exts.ext-Tuple{Colon}","page":"Manual","title":"Exts.ext","text":"Exts.ext(::Colon) -> Vector{Pair{Symbol, Maybe{Module}}}\n\n\n\n\n\n","category":"method"},{"location":"#Exts.ext-Tuple{Symbol, Vararg{Symbol}}","page":"Manual","title":"Exts.ext","text":"Exts.ext(x::Symbol) -> Maybe{Module}\n\n\n\n\n\n","category":"method"},{"location":"#Exts.floatminmax","page":"Manual","title":"Exts.floatminmax","text":"floatminmax(T = Float64)\n\nReturn (floatmin(T), floatmax(T)).\n\nSee floatmin, floatmax. See also maxintfloat.\n\n\n\n\n\n","category":"function"},{"location":"#Exts.freeze-Union{Tuple{AbstractDict{K, V}}, Tuple{V}, Tuple{K}} where {K, V}","page":"Manual","title":"Exts.freeze","text":"freeze(d::AbstractDict{K, V}) where {K, V} -> LDict{<:K, <:V}\n\nRender a dictionary immutable by converting it to a Tuple-backed LittleDict. The Tuple-backed LittleDict is faster than the Vector-backed LittleDict, particularly when the keys are all concretely typed.\n\n\n\n\n\n","category":"method"},{"location":"#Exts.invsqrt-Tuple{T} where T<:Real","page":"Manual","title":"Exts.invsqrt","text":"invsqrt(x::T) where T <: Real -> AbstractFloat\n\nReturn sqrtx^-1.\n\nSee also sqrt.\n\nExamples\n\njulia> invsqrt(4)\n0.5\n\n\n\n\n\n","category":"method"},{"location":"#Exts.isdir-Tuple{AbstractString}","page":"Manual","title":"Exts.isdir","text":"Exts.isdir(path::AbstractString) -> Bool\n\nReturn true if path is a directory, false otherwise.\n\nExamples\n\njulia> Exts.isdir(homedir())\ntrue\n\njulia> Exts.isdir(\"not/a/directory\")\nfalse\n\nSee also isfile and ispath.\n\n\n\n\n\n","category":"method"},{"location":"#Exts.isdirpath-Tuple{AbstractString}","page":"Manual","title":"Exts.isdirpath","text":"Exts.isdirpath(path::AbstractString) -> Bool\n\nDetermine whether a path refers to a directory (for example, ends with a path separator).\n\nExamples\n\njulia> Exts.isdirpath(\"/home\")\nfalse\n\njulia> Exts.isdirpath(\"/home/\")\ntrue\n\n\n\n\n\n","category":"method"},{"location":"#Exts.lmap","page":"Manual","title":"Exts.lmap","text":"lmap(f, iterators...)\n\nCreate a lazy mapping. This is another syntax for writing (f(args...) for args in zip(iterators...)). Equivalent to Iterators.map.\n\nSee also map.\n\nExamples\n\njulia> collect(lmap(x -> x^2, 1:3))\n3-element Vector{Int64}:\n 1\n 4\n 9\n\n\n\n\n\n","category":"function"},{"location":"#Exts.maybe","page":"Manual","title":"Exts.maybe","text":"Maybe{T} <- Union{T, Nothing}\nmaybe(T::Type...) -> Maybe{Union{T...}}\n\n\n\n\n\n","category":"function"},{"location":"#Exts.notmissing-Tuple{Any}","page":"Manual","title":"Exts.notmissing","text":"notmissing(x)\n\nThrow an error if x === missing, and return x if not.\n\nSee also notnothing.\n\n\n\n\n\n","category":"method"},{"location":"#Exts.polar-Tuple{Real, Real}","page":"Manual","title":"Exts.polar","text":"polar(radius::Real, azimuth::Real) -> Complex{<:AbstractFloat}\n\nReturn rθ, where θ is in degrees. Equivalent to radius∠(azimuth).\n\nSee also ∠.\n\n\n\n\n\n","category":"method"},{"location":"#Exts.readstr-Tuple{Any}","page":"Manual","title":"Exts.readstr","text":"readstr(x) -> String\n\nRead the entirety of x as a string. Equivalent to read(x, String).\n\nSee also read, readchomp.\n\n\n\n\n\n","category":"method"},{"location":"#Exts.stdpath-Tuple{AbstractString, Vararg{AbstractString}}","page":"Manual","title":"Exts.stdpath","text":"stdpath(path::AbstractString...; real = false) -> String\n\nStandardize a path (or a set of paths, by joining them together), removing \".\" and \"..\" entries and changing path separator to the standard \"/\".\n\nIf path is a directory, the returned path will end with a \"/\".\n\nIf real is true, symbolic links are expanded, however the path must exist in the filesystem. On case-insensitive case-preserving filesystems, the filesystem's stored case for the path is returned.\n\nExamples\n\njulia> stdpath(\"/home/user/../example.jl\")\n\"/home/example.jl\"\n\njulia> stdpath(\"Documents\\\\Julia\\\\\")\n\"Documents/Julia/\"\n\n\n\n\n\n","category":"method"},{"location":"#Exts.typeminmax-Tuple{Any}","page":"Manual","title":"Exts.typeminmax","text":"typeminmax(T)\n\nReturn (typemin(T), typemax(T)).\n\nSee typemin, typemax.\n\n\n\n\n\n","category":"method"},{"location":"#Exts.walkdir","page":"Manual","title":"Exts.walkdir","text":"Exts.walkdir(path::AbstractString = pwd(); topdown = true) -> Channel\n\nReturn an iterator that walks the directory tree of a directory.\n\nThe iterator returns a tuple containing (path, dirs, files). Each iteration path will change to the next directory in the tree; then dirs and files will be vectors containing the directories and files in the current path directory. The directory tree can be traversed top-down or bottom-up. The returned iterator is stateful so when accessed repeatedly each access will resume where the last left off, like Iterators.Stateful.\n\nSee also readdir, Base.walkdir.\n\nExamples\n\nfor (path, ds, fs) ∈ Exts.walkdir(\".\")\n\t@info \"Directories in $path\"\n\tfor d ∈ ds\n\t\tprintln(path * d) # path to directories\n\tend\n\t@info \"Files in $path\"\n\tfor f ∈ fs\n\t\tprintln(path * f) # path to files\n\tend\nend\n\n\n\n\n\n","category":"function"},{"location":"#Exts.∠-Tuple{Real}","page":"Manual","title":"Exts.∠","text":"∠(azimuth::Real) -> Complex{<:AbstractFloat}\n\nReturn 1θ, where θ is in degrees. Equivalent to polar(1, azimuth).\n\nSee also polar, Exts.cis.\n\n\n\n\n\n","category":"method"},{"location":"FITSIO/#API-reference","page":"FITSIO","title":"API reference","text":"","category":"section"},{"location":"FITSIO/#FITSIOExt.FITSIOExt","page":"FITSIO","title":"FITSIOExt.FITSIOExt","text":"FITSIOExt\n\n\n\n\n\n","category":"module"},{"location":"FITSIO/#FITSIODataFramesExt.FITSIODataFramesExt","page":"FITSIO","title":"FITSIODataFramesExt.FITSIODataFramesExt","text":"FITSIODataFramesExt\n\n\n\n\n\n","category":"module"},{"location":"FITSIO/#Types","page":"FITSIO","title":"Types","text":"","category":"section"},{"location":"FITSIO/#FITSIO.EitherTableHDU","page":"FITSIO","title":"FITSIO.EitherTableHDU","text":"EitherTableHDU <- Union{ASCIITableHDU, TableHDU}\n\n\n\n\n\n","category":"type"},{"location":"FITSIO/#FITSIO.HDU","page":"FITSIO","title":"FITSIO.HDU","text":"HDU  <- Union{ImageHDU, ASCIITableHDU, TableHDU}\n\n\n\n\n\n","category":"type"},{"location":"FITSIO/#Macros","page":"FITSIO","title":"Macros","text":"","category":"section"},{"location":"FITSIO/#Functions","page":"FITSIO","title":"Functions","text":"","category":"section"},{"location":"FITSIO/#Base.get-Tuple{FITSIO.FITS, AbstractString, Integer}","page":"FITSIO","title":"Base.get","text":"get(f::FITS, name::AbstractString, default::Integer) -> HDU\n\nSee also get.\n\n\n\n\n\n","category":"method"},{"location":"FITSIO/#Base.read","page":"FITSIO","title":"Base.read","text":"read(t::EitherTableHDU, Vector{Array},\n\tcolnames::AbstractVector{<:SymOrStr} = FITSIO.colnames(t)) -> Vector\n\nRead a Vector of columns from the given table (of type ASCIITableHDU or TableHDU). Each column is of type Array.\n\n\n\n\n\n","category":"function"},{"location":"FITSIO/#Base.read-2","page":"FITSIO","title":"Base.read","text":"read(t::EitherTableHDU, Vector,\n\tcolnames::AbstractVector{<:SymOrStr} = FITSIO.colnames(t)) -> Vector\n\nRead a Vector of columns from the given table (of type ASCIITableHDU or TableHDU). Each column is of type AbstractVector (more specifically, either Vector or AbstractSlices{S, 1} where S).\n\nSee also Slices.\n\n\n\n\n\n","category":"function"},{"location":"FITSIO/#Base.read-3","page":"FITSIO","title":"Base.read","text":"read(t::EitherTableHDU, DataFrame,\n\tcolnames::AbstractVector{<:SymOrStr} = FITSIO.colnames(t)) -> DataFrame\n\nRead a DataFrame from the given table (of type ASCIITableHDU or TableHDU).\n\n\n\n\n\n","category":"function"},{"location":"Dates/#API-reference","page":"Dates","title":"API reference","text":"","category":"section"},{"location":"Dates/#DatesExt.DatesExt","page":"Dates","title":"DatesExt.DatesExt","text":"DatesExt\n\n\n\n\n\n","category":"module"},{"location":"Dates/#Types","page":"Dates","title":"Types","text":"","category":"section"},{"location":"Dates/#DatesExt.EPOCH_DJD","page":"Dates","title":"DatesExt.EPOCH_DJD","text":"EPOCH_DJD::DateTime =  1899-12-31T12:00:00\n\n\n\n\n\n","category":"constant"},{"location":"Dates/#DatesExt.EPOCH_J2K","page":"Dates","title":"DatesExt.EPOCH_J2K","text":"EPOCH_J2K::DateTime =  2000-01-01T12:00:00\n\n\n\n\n\n","category":"constant"},{"location":"Dates/#DatesExt.EPOCH_JUL","page":"Dates","title":"DatesExt.EPOCH_JUL","text":"EPOCH_JUL::DateTime = -4713-11-24T12:00:00\n\n\n\n\n\n","category":"constant"},{"location":"Dates/#DatesExt.EPOCH_M2K","page":"Dates","title":"DatesExt.EPOCH_M2K","text":"EPOCH_M2K::DateTime =  2000-01-01T00:00:00\n\n\n\n\n\n","category":"constant"},{"location":"Dates/#DatesExt.EPOCH_MJD","page":"Dates","title":"DatesExt.EPOCH_MJD","text":"EPOCH_MJD::DateTime =  1858-11-17T00:00:00\n\n\n\n\n\n","category":"constant"},{"location":"Dates/#DatesExt.EPOCH_NIX","page":"Dates","title":"DatesExt.EPOCH_NIX","text":"EPOCH_NIX::DateTime =  1970-01-01T00:00:00\n\n\n\n\n\n","category":"constant"},{"location":"Dates/#DatesExt.EPOCH_RJD","page":"Dates","title":"DatesExt.EPOCH_RJD","text":"EPOCH_RJD::DateTime =  1858-11-16T12:00:00\n\n\n\n\n\n","category":"constant"},{"location":"Dates/#Macros","page":"Dates","title":"Macros","text":"","category":"section"},{"location":"Dates/#Functions","page":"Dates","title":"Functions","text":"","category":"section"},{"location":"Dates/#Dates.today-Tuple{Type{Dates.UTC}}","page":"Dates","title":"Dates.today","text":"today(::Type{UTC}) -> Date\n\nReturn the date portion of now(UTC).\n\nSee also now, today.\n\n\n\n\n\n","category":"method"},{"location":"Dates/#Exts.datetime2mjd","page":"Dates","title":"Exts.datetime2mjd","text":"datetime2mjd(dt::DateTime) -> Float64\n\n\n\n\n\n","category":"function"},{"location":"Dates/#Exts.mjd2datetime","page":"Dates","title":"Exts.mjd2datetime","text":"mjd2datetime(x::Real) -> DateTime\n\n\n\n\n\n","category":"function"}]
}
